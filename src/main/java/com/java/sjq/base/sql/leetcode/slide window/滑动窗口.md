[æˆ‘å†™äº†é¦–è¯—ï¼ŒæŠŠæ»‘åŠ¨çª—å£ç®—æ³•ç®—æ³•å˜æˆäº†é»˜å†™é¢˜ :: labuladongçš„ç®—æ³•å°æŠ„](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--f7a92/)

# æ¨¡æ¿

```java
// æ³¨æ„ï¼šjava ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ cpp ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç è¿˜æœªç»è¿‡åŠ›æ‰£æµ‹è¯•ï¼Œä»…ä¾›å‚è€ƒï¼Œå¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ cpp ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

/* æ»‘åŠ¨çª—å£ç®—æ³•æ¡†æ¶ */
void slidingWindow(String s) {
    Map<Character, Integer> window = new HashMap<>();
    
    int left = 0, right = 0;
    while (right < s.length()) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        char c = s.charAt(right);
        // å¢å¤§çª—å£
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        ...

        /*** debug è¾“å‡ºçš„ä½ç½® ***/
        // æ³¨æ„åœ¨æœ€ç»ˆçš„è§£æ³•ä»£ç ä¸­ä¸è¦ print
        // å› ä¸º IO æ“ä½œå¾ˆè€—æ—¶ï¼Œå¯èƒ½å¯¼è‡´è¶…æ—¶
        System.out.printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (window needs shrink) {
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            char d = s.charAt(left);
            // ç¼©å°çª—å£
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            ...
        }
    }
}

```

# [438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² `s` å’Œ `p`ï¼Œæ‰¾åˆ° `s` ä¸­æ‰€æœ‰ `p` çš„ **å¼‚ä½è¯** çš„å­ä¸²ï¼Œè¿”å›è¿™äº›å­ä¸²çš„èµ·å§‹ç´¢å¼•ã€‚ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚

**å¼‚ä½è¯** æŒ‡ç”±ç›¸åŒå­—æ¯é‡æ’åˆ—å½¢æˆçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ç›¸åŒçš„å­—ç¬¦ä¸²ï¼‰ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: s = "cbaebabacd", p = "abc"
è¾“å‡º: [0,6]
è§£é‡Š:
èµ·å§‹ç´¢å¼•ç­‰äº 0 çš„å­ä¸²æ˜¯ "cba", å®ƒæ˜¯ "abc" çš„å¼‚ä½è¯ã€‚
èµ·å§‹ç´¢å¼•ç­‰äº 6 çš„å­ä¸²æ˜¯ "bac", å®ƒæ˜¯ "abc" çš„å¼‚ä½è¯ã€‚
```

```java
class Solution {
 List<Integer> res = new LinkedList<>();
    Map<Character, Integer> win = new HashMap<>();
    Map<Character, Integer> need = new HashMap<>();


    public List<Integer> findAnagrams(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        int sLen = s.length();
        int tLen = t.length();
        int left=0, right =0;
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int valid = 0;

        while(right<sLen){
            char rightChar = s.charAt(right);
            right++;
            if(need.containsKey(rightChar)) {
                win.put(rightChar, win.getOrDefault(rightChar, 0) + 1);
                if(win.get(rightChar).equals(need.get(rightChar))){
                    valid++;
                }
            }

            if(right - left >= t.length()){
                if(valid==need.size()){
                    res.add(left);
                }
                char leftChar = s.charAt(left);
                left++;
                if(need.containsKey(leftChar)){
                   if(win.get(leftChar).equals(need.get(leftChar))){
                       valid--;
                   }
                   win.put(leftChar, win.getOrDefault(leftChar,0) -1);
                }
            }
        }
        return res;  // è‹¥æ²¡æ‰¾åˆ°å°±æ˜¯ç©º
    }
    public void t(){
        String s = "cbaebabacd", p = "abc";
        List<Integer> anagrams = findAnagrams(s, p);
        System.out.println(Arrays.toString(anagrams.toArray()));
    }

}
```



# [76. æœ€å°è¦†ç›–å­ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/minimum-window-substring/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ã€ä¸€ä¸ªå­—ç¬¦ä¸² `t` ã€‚è¿”å› `s` ä¸­æ¶µç›– `t` æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ `s` ä¸­ä¸å­˜åœ¨æ¶µç›– `t` æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² `""` ã€‚

**æ³¨æ„ï¼š**

-   å¯¹äº `t` ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº `t` ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚
-   å¦‚æœ `s` ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šs = "ADOBECODEBANC", t = "ABC"
è¾“å‡ºï¼š"BANC"
è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² "BANC" åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ 'A'ã€'B' å’Œ 'C'ã€‚
```



```java
package com.java.sjq.dataStructure;

import org.junit.Test;

import java.util.*;

/**
 è¾“å…¥ï¼šs = "ADOBECODEBANC", t = "ABC"
 è¾“å‡ºï¼š"BANC"
 è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² "BANC" åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ 'A'ã€'B' å’Œ 'C'ã€‚
 */
public class Solution {
    Map<Character, Integer> win = new HashMap<>();
    Map<Character, Integer> need = new HashMap<>();


    public String minWindow(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        int sLen = s.length();
        int tLen = t.length();
        int left=0, right =0;
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int valid = 0;

        int resStart = 0, resEnd = s.length(); // å‡è®¾ç¬¦åˆæ¡ä»¶çš„å­ä¸²çš„ èµ·å§‹ä½ç½® å’Œ é‡ç‚¹ä½ç½®[resStart, resEnd)
        boolean founded = false; // æœ‰å¯èƒ½æ²¡æ‰¾åˆ°

        while(right<sLen){
            char rightChar = s.charAt(right);
            right++;
            if(need.containsKey(rightChar)) {
                win.put(rightChar, win.getOrDefault(rightChar, 0) + 1);
                if(win.get(rightChar).equals(need.get(rightChar))){
                    valid++;
                }
            }

            while(valid == need.size()){
                founded = true;
                if(resEnd- resStart > right-left){
                    resStart = left;
                    resEnd = right;
                }
                char leftChar = s.charAt(left);
                left++;
                if(need.containsKey(leftChar)){
                   if(win.get(leftChar).equals(need.get(leftChar))){
                       valid--;
                   }
                   win.put(leftChar, win.getOrDefault(leftChar,0) -1);
                }
            }
        }

        // æœ‰å¯èƒ½æ ¹æœ¬æ²¡æ‰¾åˆ°
        return founded ? new String(sChars, resStart, resEnd-resStart) : "";
    }
    @Test
    public void t(){
        String s = "ADOBECODEBANC", t = "ABC";
        String nagrams = minWindow(s, t);
        System.out.println(nagrams);
    }

}
```



#  [567. å­—ç¬¦ä¸²çš„æ’åˆ— - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/permutation-in-string/)

ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² `s1` å’Œ `s2` ï¼Œå†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ `s2` æ˜¯å¦åŒ…å« `s1` çš„æ’åˆ—ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

æ¢å¥è¯è¯´ï¼Œ`s1` çš„æ’åˆ—ä¹‹ä¸€æ˜¯ `s2` çš„ **å­ä¸²** ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šs1 = "ab" s2 = "eidbaooo"
è¾“å‡ºï¼štrue
è§£é‡Šï¼šs2 åŒ…å« s1 çš„æ’åˆ—ä¹‹ä¸€ ("ba").

```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šs1= "ab" s2 = "eidboaoo"
è¾“å‡ºï¼šfalse
```



```java


class Solution {
    Map<Character, Integer> win = new HashMap<>();
    Map<Character, Integer> need = new HashMap<>();


    public boolean checkInclusion(String t, String s) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        int sLen = s.length();
        int tLen = t.length();
        int left=0, right =0;
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int valid = 0;

        while(right<sLen){
            char rightChar = s.charAt(right);
            right++;
            if(need.containsKey(rightChar)) {
                win.put(rightChar, win.getOrDefault(rightChar, 0) + 1);
                if(win.get(rightChar).equals(need.get(rightChar))){
                    valid++;
                }
            }

            if(right - left >= t.length()){
                if(valid==need.size()){
                    return true;
                }
                char leftChar = s.charAt(left);
                left++;
                if(need.containsKey(leftChar)){
                   if(win.get(leftChar).equals(need.get(leftChar))){
                       valid--;
                   }
                   win.put(leftChar, win.getOrDefault(leftChar,0) -1);
                }
            }
        }
        return false;
    }


}
```



# 3\. [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)



ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: s = "abcabcbb"
è¾“å‡º: 3 
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚

```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: s = "bbbbb"
è¾“å‡º: 1
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "b"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚
```



```java
class Solution {
    Map<Character, Integer> win = new HashMap<>();

    public  int lengthOfLongestSubstring(String s) {
        char[] sChars = s.toCharArray();
        int sLen = s.length();
        int left=0, right =0;


        int res = 0;
        while(right<sLen){
            char rightChar = sChars[right];
            right++;
            win.put(rightChar, win.getOrDefault(rightChar, 0) + 1);

            while (win.getOrDefault(rightChar, 0) > 1){
                char leftChar = sChars[left];
                win.put(leftChar, win.get(leftChar) - 1);
                left++;
            }
            res = Math.max(res, right - left);

        }

        return res;
    }
}
```

