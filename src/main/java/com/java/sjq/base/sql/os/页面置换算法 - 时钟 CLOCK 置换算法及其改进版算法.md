[(110条消息) 页面置换算法-CLOCK置换算法及其改进版算法\_xzhws的博客-CSDN博客\_改进的clock置换算法](https://blog.csdn.net/zhuixun_/article/details/85336417)

本文主要介绍页面置换算法中的CLOCK置换算法。页面置换算法中的LRU算法最接近理想情况下的OPT算法，但是实现起来比较困难且开销较大，所以很多设计者试图用开销比较小的算法接近LRU算法，CLOCK算法就是其中一种。

# **1.简单的CLOCK算法**

是通过给每一个访问的页面关联一个**附加位(reference bit)**，有些地方也叫做**使用位(use bit)**。他的主要思想是：当某一页装入主存时，将use bit置成1；如果该页之后又被访问到，使用位也还是标记成1。对于页面置换算法，候选的帧集合可以看成是一个循环缓冲区，并且有一个指针和缓冲区相关联。遇到页面替换时，指针指向缓冲区的下一帧。如果这页进入主存后发现没有空余的帧(frame)，即所有页面的使用位均为1，那么这时候从指针开始循环一个缓冲区，将之前的使用位都清0，并且留在最初的位置上，换出该桢对应的页。

以下面这个页面置换过程为例，访问的页面依次是:1,2,3,4,1,2,5,1,2,3,4,5。主存有4个空闲的帧，每个页面对应的结构为**(页面号，使用位)**。

1.  最开始页面号1进入主存，主存里面有空闲的帧，将其使用位记成1，由于主存中之前没有页面1，所以会发生缺页中断。
2.  同理随后的页面2，3，4进入主存，将其使用位记成1，发生缺页中断。
3.  当之后的页面1，2进入主存时，由于页面1,2已经在主存中，不做处理。
4.  当之后的页面5进入主存时，主存内没有空余的帧，这时候随着指针循环移动整个缓冲区，将之前页面的使用位全部清0，即这时候页面1,2,3,4对应的使用位全部为0，指针回到最初的位置，将页面1替换出去，页面5换入主存，同时使用位标记成1。以此类推，可知CLOCK共发生10次缺页中断。

![](%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20-%20%E6%97%B6%E9%92%9F%20CLOCK%20%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%89%88%E7%AE%97%E6%B3%95.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podWl4dW5f,size_16,color_FFFFFF,t_70.jpeg)

# **2.改进型的CLOCK算法**

（相当于普通的 clock 算法加上 [NRU 算法](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#_2-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8)）

在之前的CLOCK算法上面除了**使用位(used bit)**，还增加了一个**修改位(modified bit)**，有些地方也叫做dirty bit。现在每一页有两个状态，分别是**(使用位，修改位)**，可分为以下四种情况考虑：

> **(0,0)**：最近没有使用使用也没有修改，最佳状态！
>
> **(0,1)**：修改过但最近没有使用，将会被写
>
> **(1,0)**：使用过但没有被修改，下一轮将再次被用
>
> **(1,1)**：使用过也修改过，下一轮页面置换最后的选择

以下面这个页面置换过程为例：访问的页面依次是:0,1,3,6,2,4,5,2,5,0,3,1,2,5,4,1,0，其中红色数字表示将要修改的页面，即他们的modified bit将被设置成1，在下图中这些页面用**_斜体_**表示，使用位和修改位如下图所示。下面的"Fault ?"表示缺页时查找空闲frame的次数。

![](%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20-%20%E6%97%B6%E9%92%9F%20CLOCK%20%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%89%88%E7%AE%97%E6%B3%95.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podWl4dW5f,size_16,color_FFFFFF,t_70-1676559004348-21.png)

> 页面替换的顺序：
>
> 1.  从指针当前的位置开始寻找主存中满足(使用位，修改位)为**(0,0)**的页面；
> 2.  如果第1步没有找到满足条件的，接着寻找状态为**(0,1)**页面；
> 3.  如果依然没有找到，指针回到最初的位置，将集合中所有页面的使用位设置成0。重复第1步，并且如果有必要，重复第2步，这样一定可以找到将要替换的页面。

以下面替换的流程为例: 

1.当页面0来时，Frame0空闲，所以换入页面0，修改状态为**(1,0)**，同时发生缺页中断。

2.当访问页面1时，由于页面1,将要被修改，其状态设置为**(1,1)**，同时发生缺页中断。

3.同理对于接下来的页面3,6，将其状态设置为**(1,0)**,，同时发生缺页中断。

4.对于接下来的页面2，按照之前的页面置换算法的顺序，他现在主存中找状态为**(0,0)**的页面，发现没有....然后执行算法的第二步，找状态为**(0,1)**的页面，发现还是没有.....这时候把主存里面所有页面的used bit清零，再重复执行算法的第一步，此时由于页面0的状态已经变成**(0,0)**，页面2把页面0替换出主存。同时由于在之前的设计中页面2属于将要被修改(modify)的页面，故将其状态设置为**(1,1)**。由于经历了两轮查找，所以"Fault ?"对应的查找次数为2\*4+1=9。同理可类推访问其他页面的情况。最后可知缺页次数为13次。

![](%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20-%20%E6%97%B6%E9%92%9F%20CLOCK%20%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%89%88%E7%AE%97%E6%B3%95.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podWl4dW5f,size_16,color_FFFFFF,t_70-1676559004348-22.png)

欢迎指正~ 

参考资料：

[http://courses.cs.tamu.edu/bart/cpsc410/Supplements/Slides/page-rep3.pdf](http://courses.cs.tamu.edu/bart/cpsc410/Supplements/Slides/page-rep3.pdf)

资料更新：

[https://github.com/totororz/Examples-of-page-replacement-problems/blob/master/page-rep3.pdf](https://github.com/totororz/Examples-of-page-replacement-problems/blob/master/page-rep3.pdf)