[(132条消息) 计网 | GBN、SR、TCP的联系与区别\_gbn sr tcp\_西皮呦的博客-CSDN博客](https://blog.csdn.net/weixin_47187147/article/details/127484471)

        **重传** 对于丢失分组 n，在GBN中，发送方会重传n及n以后的数据包；在SR中，只会重传n。
    
        **缓存** 对于乱序达到的分组，在GBN中，接受段端会直接丢弃；在SR中，会把它们缓存下来。
    
        **定时器** 在GBN中一个连接只会设置一个定时器，在SR中会为每个分组设置定时器。
    
        而TCP呢？
    
        重传和缓存像SR，定时器像GBN。
    
        TCP协议中的ack指的是 期望收到的分组。而GBN，SR中ack指的是已经确认的分组。

### GBN：

-   如果某个报文段没有被正确接收，则从这个报文段到后面的报文段都要重新发送。
-   采用累计应答的方式。例如接收端返回ACK=3，则证明报文段3以及之前的报文段都被正确接收。
-   这里顺便解释一下为什么GBN可以采用累计应答的方式？怎么就能保证3之前的被正确接收了呢？
-   这还要由GBN的工作机制来决定：在GBN机制下，在接收端的运输层一次只交付给上层一个分组，并且保证是按序交付的，因此如果分组k已接收，则所有序号小于k的分组也已经交付了。
-   接收端不对失序到达的分组进行缓存。

### SR：

-   接收方设置缓存区，用于接收失序到达的分组。（从这里可以感受到，所谓的**GBN中的发送端窗口**和**SR中的发送端与接收端的窗口**其实就是缓存区，用于缓存分组。注意，由于GBN是单个分组交付，不设置缓存区，所以GBN的接收端是没有窗口的）
-   为每个报文段设置单独的计时器，单个分组计时器超时只重发这一个报文段。
-   接收端返回ACK是当前接收成功报文段的序号，SR不采用累计应答的方式。

### TCP：

-   TCP使用累计应答的方式。这一点与GBN类似。
-   TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）
-   TCP使用快速重传机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。
-   注意：TCP中的ACK是指接收端希望从发送端收到的下一字节的序号。例如发送端发送了编号为0-5的字节，这时接收端成功接收后就会发送ACK为6。
-   注意：这里介绍的TCP这是理论上的，在实际使用过程中，大家加入了很多其他的机制等。目前计网学习的都是基础理论的知识。

        GBN和SR是[滑动窗口协议](https://so.csdn.net/so/search?q=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE&spm=1001.2101.3001.7020)的两个典型例子，可以看做是“理论”协议，实际协议可以完全按着GBN或SR协议实现，当然也可以根据需要引入或综合不同的机制。TCP协议可以认为综合了GBN协议和SR协议的一些机制，比如TCP协议采用累积确认机制、通常在接收端提供缓存等。

【例题】

 ![](https://img-blog.csdnimg.cn/335bc000d895473990ec8c7d2a953df2.png)

![](https://img-blog.csdnimg.cn/471c4eb57c8a4989b9f433c3877c85ef.png) 

___

本文内容参考于

[GBN,SR,TCP区别\_canaryW的博客-CSDN博客\_gbn sr tcp](https://blog.csdn.net/cobracanary/article/details/102148951 "GBN,SR,TCP区别_canaryW的博客-CSDN博客_gbn sr tcp")

[TCP滑动窗口的实现是基于GBN还是SR? - 知乎](https://www.zhihu.com/question/44602610?utm_id=0 "TCP滑动窗口的实现是基于GBN还是SR? - 知乎")

[对TCP ，GBN，SR的一点理解总结](https://www.zhihu.com/tardis/landing/m/360/art/126312611 "对TCP ，GBN，SR的一点理解总结")