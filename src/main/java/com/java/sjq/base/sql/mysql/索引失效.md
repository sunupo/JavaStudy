# [ Mysql之索引失效原理分析](https://blog.csdn.net/BestandW1shEs_lsy/article/details/122339769)

> ## 一. 前言

[索引失效](https://so.csdn.net/so/search?q=%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88&spm=1001.2101.3001.7020)是针对的是联合索引，在没有遵守最佳左法则、使用like和%、or 等情况下索引会失效。

但是为什么索引会失效 ？

索引失效和 Innodb 引擎的 B+树 存储方式有关，本文会对失效的原理进行逐一分析。

> ## 二. B+树的索引

1\. 单索引的B+树如下图：

![img](https://img-blog.csdnimg.cn/img_convert/940629e6037e4d9ffe08bc5e703e5465.png)

单值索引在B+树结构里，一个节点只存一个键值对，键值对都是有序的。

2\. [联合索引](https://so.csdn.net/so/search?q=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020)的B+如下图：![](https://img-blog.csdnimg.cn/e281d1d8c7fb4d62a3d948945fba8d6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmVzdGFuZFcxc2hFcw==,size_20,color_FFFFFF,t_70,g_se,x_16)

联合索引在B+树结构里，一个节点的键值对的数量不是1，而是大于等于2，键值对都是有序的。

(1) 该图是由数据库的 a 字段和 b 字段组成一个联合索引，对于查询 SELECT \* FROM table WHERE a = xxx and b = xxx，就可以使用该联合索引。

(2) a，b排序分析：

1) a 排序：1，1，2，2，3，3(有序排列)

2) b 排序：1，2，1，4，1，2(无序排列)

直观的可以发现 a 是有序的，b 是无序的，再进一步发现在 a 确定的情况下，b 也是有序的；

比如需要对两个字段排序，都是先按照第一个字段排序，如果第一个字段出现相等的情况，就用第二个字段排序，B+树也采用了该方法进行排序。

这个就是联合索引命中的原理：即 a 本身有序，在 a 确定的情况下，b又是有序的，所以就相当于都是有序的。

> ## 三. 最佳左前缀法则

1. 遵循最佳左前缀法则：

```
select * from table where a = 1 and b = 1
```

该语句可以命中索引。

分析：

(1) a字段是有序的，所以可以通过二分查找法来定位到 a=1 的位置；

(2) 在a确定的情况下，b是相对有序的，所以同样可以通过二分查找法找到 b=2 的位置。

2. 不遵循最佳左前缀：

```
select * from table where b = 1
```

该语句不可以命中索引，索引失效。

分析：

(1) b本身是无序的，b有顺序的前提是在a确定的情况下才有序；

(2) 此时没有a，那b肯定是不能确定顺序的，所以无法用二分查找来定位到b字段的；

(3) Mysql 查找无序的数据就需要进行全表扫描；

> ## 四. 范围查找右边失效原理

```
select * from table where a > 1 and b = 2;
```

该语句不可以命中索引，索引失效。

分析：

(1) a字段是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引；

(2) b有序的前提是a确定的值，那么现在a的值是取大于1的，此时的a可以为2，也可以为3，也可以是其他值，大于1的范围也不确定的；

(3) a大于1的那部分，b字段是无序的，所以b不能用二分查找来定位，b用不到索引；

(4) 大于1的部分就需要进行全表扫描。

> ## 五. like索引失效原理

```
select * from table where id like "a%"   // %放在右边，代表查询以"a"开头的数据，a叫前缀select * from table where id like "%a%"  // 两个%%，代表查询数据中包含"a"的数据，a叫中缀select * from table where id like "%a"   // %放在左边，代表查询以"a"结尾的数据，a叫后缀
```

该语句第一条可以命中索引，第二三条不可以命中索引，索引失效。

分析：

(1) %号放右边：匹配以a作为头部的所有数据，头部的字母是有顺序的，所有可以使用索引；

(2) %号放左边：匹配以a作为尾部的所有的数据，尾部的字母是没有顺序的，所以不能按照索引顺序查询，就用不到索引；

(3) 两个%%号：匹配任意位置的字母等于a即可，由于只有头部的字母是有序的，其他位置的字母都是相对无序的，所以用不到索引。

**总结：**

简单来说，索引查找就是二分查找，凡是不能二分查找的情况都属于索引失效的情况。

# 有索引不走索引（回表）

> ## 回表

Mysql回表指的是在[InnoDB存储引擎](https://so.csdn.net/so/search?q=InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&spm=1001.2101.3001.7020)下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，二级索引的B+树叶子节点都是存放的(索引列,主键)。

例如：

有一张用户表 id(主键), username (二级索引),age

id是主键索引 username是二级索引，当我们通过二级索引查询返回记录时，例如：

select \* from t where username = "bobo";

① 通过二级索引找到 bobo记录和主键id

② 在通过主键id去主键索引B+tree找到行记录

这里就会出现一个问题，**当我们的用户表有150w条记录时， 有时候查询并没有走索引，而是通过All全盘的扫描。**这是为什么了？下面我们就简单的介绍一下全盘扫描和走索引的IO。

假如我们一行数据的大小是100字节， bobo的有50W行数据. 假设用户表的B+树高度=3

通过username索引的话：每次回表需要3次IO，50w记录需要回表50w次。那么IO = 50W \* 3

通过全盘扫描：一个页可以存放16k / 100字节 = 16 \* 1024 / 100 = 163条记录 全盘扫描则需要 150w / 163 = 0.92W 差不多是1w次IO，

通过上面对比，肯定全盘要效率高一些，这就是为什么有时候我们建立了索引，但是通过explain检测的时候我们的sql没有走索引。**因为回表的IO开销还是比较大的。**

> ## MRR
> [MySQL 的 MRR 到底是什么？ - 知乎](https://zhuanlan.zhihu.com/p/110154066)

MRR 简单的来说就是上面的回表更加效率了，如果需要50w次的回表，效率太慢了，这时候Mysql就把需要回表的主键id进行排序，然后排序过后的id再到主键B+树去取数据库，这样就大大的增加了效率。 我们可以通过 explain中的Extra列中的Using MRR来判断是否使用了MRR.

主键索引 的 IN 查询也会用到 MRR。