[select for update 什么时候释放锁](https://blog.csdn.net/weixin_39608301/article/details/111606253?app_version=5.14.1&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22111606253%22%2C%22source%22%3A%22qq_33399534%22%7D&utm_source=app)

![](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/original-1676725608959-69.png)



版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。

![2d4b4b1415410c82b2fdfa1896004801.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/2d4b4b1415410c82b2fdfa1896004801.jpeg)

# **乐观锁（Optimistic Lock）**

[乐观锁](https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020)的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。

乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者[时间戳](https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020)。

相对[悲观锁](https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020)而言，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，举个例子：

使用数据版本（或保存时间戳）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值+1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

> 1、select (status,version) from items where id=#{id} //查询出商品信息  
> 2、根据商品信息生成订单  
> 3、update items set status=2,version=version+1 where id=#{id} and version=#{version}; //修改商品status为2

乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：**在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。**因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

举例：

> 1.查询出商品信息  
> select (status,status,version) from t\_goods where id=#{id}  
> 2.根据商品信息生成订单  
> 3.修改商品status为2  
> update t\_goods  
> set status=2,version=version+1  
> where id=#{id} and version=#{version};

除了自己手动实现乐观锁之外，现在网上许多框架已经封装好了乐观锁的实现，如hibernate。

# **悲观锁（Pessimistic Lock）**

### “*select for update 即排他锁*,排他锁又称为写锁,简称X锁,

### select for update获取的行锁会在当前事务结束时自动释放，**因此必须在事务中使用**。

悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的**“一锁二查三更新”**即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。**当数据库执行select for update时会获取被select中的数据行的行锁**，因此其他并发执行的select for update如果试图选中同一行则会**发生排斥**（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，**因此必须在事务中使用**。

这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。

与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。**共享锁和排它锁是悲观锁的不同的实现**，它俩都属于悲观锁的范畴。

**实验一下：**

![b5885d36aa5a4c9e38dbbed6bad49102.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/b5885d36aa5a4c9e38dbbed6bad49102-1676725608960-71.png)

一个未提交的for update事务

![cea26cc88af1e0a3059fd28ff631f514.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/cea26cc88af1e0a3059fd28ff631f514-1676725608960-74.png)

另一个session中select没有问题

![79471ba5b91401e92a40821c1dd38821.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/79471ba5b91401e92a40821c1dd38821-1676725608960-76.png)

因为有这条记录的行锁未释放，所以无法update

与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时id为1记录就被锁定，其它的事务必须等本次事务提交之后才能执行。这样就可以保证当前的数据不会被其它事务修改。

上面提到，使用select…for update会把数据给锁住，不过需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，**所以只有明确地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据)** ，**否则MySQL 将会执行Table Lock (表锁)。**除了主键外，使用索引也会影响数据库的锁定级别。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理该行记录。

悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。所以与悲观锁相对的就是乐观锁。

## **共享锁（Shared Lock）** 

### lock in share mode

共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。比如，你们家有一个大门，有多个钥匙，你和你媳妇各有一把，你们都能打开这扇门，并进去to do somethings...

对于悲观锁，一般数据库已经实现了，共享锁也属于悲观锁的一种，共享锁通过lock in share mode来调用。

比如，下面这个例子，Session A开启一个事务，但并不执行commit语句：

_**Session A：**_

在Session A中启动一个事务，但是并不提交。

![528eb26259f415801d5eca685023d7b8.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/528eb26259f415801d5eca685023d7b8-1676725608960-78.png)

_**Session B：**_

在Session B中执行update操作，发现这条where条件是id=1的记录一直处于阻塞状态，直到超时。

![79049403d5156ef3af25f08d06c4291f.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/79049403d5156ef3af25f08d06c4291f-1676725608960-80.png)

**超时报错：**

> 1 queries executed, 0 success, 1 errors, 0 warnings  
> 查询：update t1 set a = '123' where id =1  
> 错误代码： 1205  
> Lock wait timeout exceeded; try restarting transaction  
> 执行耗时 : 0 sec  
> 传送时间 : 0 sec  
> 总耗时 : 1 min 14 sec

那么证明，对于id=1的记录加锁成功了，在Session A还没有commit之前，这条id=1的记录被锁住了，只有在上一个事务释放掉锁后才能进行操作。

**试图使用LOCK IN SHARE MODE:**

![81261f469c5b0b4ed0ff793a91c16cdf.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/81261f469c5b0b4ed0ff793a91c16cdf-1676725608960-82.png)

依然是不能update的。原因是，Mysql底层对于update/insert/delete的操作自动会加排它锁。

**select情况又会如何呢？**

![e0b3daa610911aeeed172f4d5a247398.png](select%20for%20update%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E9%94%81.assets/e0b3daa610911aeeed172f4d5a247398-1676725608960-84.png)

select是正常的。

## **总结**

-   乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能
-   乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方
