# [(122条消息) JVM垃圾回收——三色标记法\_jvm 三色标记法\_熟透的蜗牛的博客-CSDN博客](https://blog.csdn.net/weixin_39555954/article/details/127623284?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127623284-blog-122947422.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

**目录**

[一、什么是三色标记](https://blog.csdn.net/weixin_39555954/article/details/127623284?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127623284-blog-122947422.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4#t0)

[二、三色标记的过程](https://blog.csdn.net/weixin_39555954/article/details/127623284?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127623284-blog-122947422.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4#t1)

[三、三色标记的缺点](https://blog.csdn.net/weixin_39555954/article/details/127623284?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127623284-blog-122947422.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4#t2)

[四、垃圾回收机如何弥补三色标记的缺点](https://blog.csdn.net/weixin_39555954/article/details/127623284?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127623284-blog-122947422.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4#t3)

___

        在CMS、G1这种并发的垃圾收集器收集对象时，假如一个对象A被GC线程标记为不可达对象，但是用户线程又将A对象标记为可达对象，那么此时直接对A对象做清除时那将会发生很严重的错误，那么对象A是如何摆脱被清除的命运呢？今天就简单来聊聊这个问题。

## 一、什么是三色标记

        主流的垃圾收集器基本上都是基于可达性分析算法来判定对象是否存活的。根据**对象是否被垃圾收集器扫描过**而用白、灰、黑三种颜色来标记对象的状态的一种方法。而其中

-   **白色：**表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始阶段，所有的对象都是白色的，若在分析结束之后对象仍然为白色，则表示这些对象为不可达对象，对这些对象进行回收。
-   **灰色：**表示对象已经被垃圾收集器访问过，但是这个对象至少存在一个引用（属性）还没有被扫描过。
-   **黑色：**表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过。黑色表示这个对象扫描之后依然存活，是可达性对象，如果有其他对象引用指向了黑色对象，无须重新扫描，黑色对象不可能不经过灰色对象直接指向某个白色对象。

## 二、三色标记的过程

**初始状态**

        初始阶段只有GC Roots是黑色的，其他对象都是白色的，如果没有被黑色对象引用那么最终都会被当做垃圾对象回收。

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/e4b731474db9430582b941a9871f4fe6.png)

**开始扫描**

        A和B均为扫描过的对象并且其引用也已经被[垃圾回收器](https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8&spm=1001.2101.3001.7020)扫描过所以此时A、B对象均变为了黑色，而刚扫描到对象C，由于C的D和E还没有被扫描到，所以C暂时为灰色。

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/499cf810c9014813a9b6cb34f0ca9651.png)

**顺利扫描结束**

        此时扫描完成，黑色对象就是存活的对象，即可可达对象，白色对象G为不可达对象，在[垃圾回收](https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020)时就会被回收掉。

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/80a57212b22d413d8438cb3d7ce83708.png)

## 三、三色标记的缺点

​    我们知道CMS和G1等垃圾回收器是一个并发回收的垃圾回收器，上面的图片只是展示了一种理想状态下的三色标记，实际上在并发的情况下会存在多标和漏标的问题。

>  多标漏标指的是标记存活对象。

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/46abef7077584f1c84bea1f29d6d9861.png)

 **场景**

​    假如GC线程已经扫描到了E对象，此时E对象为灰色，这个时候用户线程将C的引用E断开，那么GC就会认为E对象是可达对象，而不会对E进行垃圾回收，但实际上E是个垃圾对象，这个时候就会产生多标问题，多标问题其实还可以接受，E作为浮动垃圾，那么等到下次垃圾回收的时候回收掉。

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/cd819b5be454490aa8169b1dd24be7d3.png)

 **场景**

​    假如用户线程先断开了C到E的引用，那么E对象就认为是不可达对象，而此时B对象又引用了E对象，但是三色标记又不会重新从B点开始标记到E，那么E就会被认为是垃圾对象，但实际上E是有引用的，那么此时对E进行垃圾回收，之后就一定会产生错误，这就是漏标问题。

## 四、垃圾回收机如何弥补三色标记的缺点

        上面演示了三色标记法存在的一些问题，那么如何解决这些问题呢。首先存在以上问题有两个条件同时满足才会发生

-   赋值器插入了一条或者多条从黑色对象到白色对象的引用。
-   赋值器删除了所有的从灰色对象到白色对象的直接引用或者间接引用。


那么要想解决并发扫描时对象消失的问题只需要破坏任何一个条件即可。因此产生了两种解决方案——增量更新（Incremental Update）和原始快照（[Snapshot](https://so.csdn.net/so/search?q=Snapshot&spm=1001.2101.3001.7020) At The Beginning, SATB）。

**==增量更新==破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时。就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象作为根对象，再重新扫描一遍。比如漏标问题中，一旦B对象直接指向了E对象，那么在并发扫描之后，就会将B对象作为灰色对象，再重新扫描一遍。这样虽然==避免了漏标==问题，但是重新标记会导致STW的时间变长。**

**==原始快照==破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后再将这些记录过的引用关系中的灰色对象为根对象再重新扫描一遍。例如漏标问题的途中，C断开E的引用关系时会保存一个快照，然后等扫描结束之后，会把C当作根再重新扫描一遍，假如B没有引用E，那么E对象也会认为是可达对象，这样E就成了浮动垃圾，只能等下次垃圾回收时再回收。**

无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过==写屏障==实现的。在HotSpot虚拟机中，**==CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用SATB来实现的。==**



# [(122条消息) 三色标记法\_静静～嗯嗯的博客-CSDN博客](https://blog.csdn.net/hejingyuan6/article/details/122947422)

## 前言

本文主要介绍了三色标记法的基本思路、多标导致的浮动垃圾、漏标的处理方案等。

## 1\. 垃圾回收的简单回顾

关于垃圾回收算法，基本就是那么几种：标记-清除、标记-复制、标记-整理。在此基础上可以增加分代（新生代/老年代），每代采取不同的回收算法，以提高整体的分配和回收效率。  
无论使用哪种算法，**标记总是必要的一步**。这是理算当然的，你不先找到垃圾，怎么进行回收？

[垃圾回收器](https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8&spm=1001.2101.3001.7020)的工作流程大体如下：

1.  **标记**出哪些对象是存活的，哪些是垃圾（可回收）；
2.  进行**回收**（清除/复制/整理），如果有移动过对象（复制/整理），还需要更新引用。

本文着重来看下**标记**的部分。

## 2\. 三色标记法

## 2.1 基本算法

要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：

最终结果：A/D/E/F/G 可达

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6Z2Z772e5Zev5Zev,size_18,color_FFFFFF,t_70,g_se,x_16.png)

我们把[遍历对象](https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020)图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：

白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。  
黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了（本对象的孩子节点也都被访问过）。  
灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态（本对象的孩子节点还没有访问）。  
 ![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/c74315b9bdc543bb876e62cca8dcefcf.gif)

标记过程：

-   初始时，所有对象都在 【白色集合】中；
-   将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
-   从灰色集合中获取对象：  
    3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；  
    3.2. 将本对象 挪到 【黑色集合】里面。
-   重复步骤3，直至【灰色集合】为空时结束。
-   结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收

问题：由于此过程是在和用户线程并发运行的情况下，对象的引用处于随时可变的情况下，那么就会造成多标和漏标的问题。

浮动垃圾：本应该被标记为白色的对象，没有被标记，造成该对象可能不会被回收。

假设已经遍历到E（变为灰色了），此时应用执行了 `objD.fieldE = null` ，D和E之间的线断开，此刻之后，对象E/F/G是“应该”被回收的。然而因为**E已经变为灰色**了，其仍会被**当作存活对象**继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即**本轮GC不会回收这部分内存**。

另外，针对并发标记开始后的**新对象**，通常的做法是直接全部**当成黑色**，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。

漏标：灰色对象指向白色对象的引用消失了，然后一个黑色的对象重新引用了白色对象。假设GC线程已经遍历到E（变为灰色了），此时应用线程先执行了：

var G = objE.fieldG;

objE.fieldG = null; // 灰色E 断开引用 白色G

objD.fieldG = G; // 黑色D 引用 白色G

此时切回GC线程继续跑，因为**E已经没有对G的引用了，所以不会将G放到灰色集合**；尽管因为D重新引用了G，但因为**D已经是黑色**了，不会再重新做遍历处理。  
最终导致的结果是：G会一直停留在白色集合中，**最后被当作垃圾进行清除**。这直接**影响到了应用程序的正确性**，是不可接受的。


漏标只有**同时满足**以下两个条件时才会发生：  
**条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。  
条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。**

**解决方案：**

写屏障 + 增量更新，当对象D的成员变量的引用发生变化时（`objD.fieldG = G;`），我们可以利用写屏障，当D是黑色G是白色的话将D标为灰色，等待遍历，即增量更新（Incremental Update）。

注：

**CMS（**Concurrent Mark Sweep**）：写屏障 + 增量更新**

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6Z2Z772e5Zev5Zev,size_20,color_FFFFFF,t_70,g_se,x_16.png) 

-   初始标记(STW initial mark)：只标记被gc root直接引用的对象
-   并发标记(Concurrent marking)
-   并发预清理(Concurrent precleaning)
-   重新标记(STW remark)
-   并发清理(Concurrent sweeping)
-   并发重置(Concurrent reset)

初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法[STW](https://so.csdn.net/so/search?q=STW&spm=1001.2101.3001.7020)(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。

并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。

并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从[新生代](https://www.baidu.com/s?wd=%E6%96%B0%E7%94%9F%E4%BB%A3&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd "新生代")晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。

重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"根对象"开始向下追溯，并处理对象关联。

并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。

并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。

重新标记必须从头扫描一次的原因：

![](%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6Z2Z772e5Zev5Zev,size_20,color_FFFFFF,t_70,g_se,x_16-1677860295005-11.png)